<!-- imports -->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-icons/core-icons.html">
<link rel="import" href="../core-icon/core-icon.html">
<link rel="import" href="../lib-d3/lib-d3.html">
<link rel="import" href="../px10-node-resize-detector/px10-element-resize-detector.html">

<!--
Responsive and configurable Polymer element for line charts based on D3.js library.

#### Roadmap for next releases:
  - scale detailed configuration
  - ticks configuration
  - hover series details
  - d3-chart element with other types configurable for series

#### Example
    <d3-line-chart metadata="{{ seriesConfiguration }}" data="{{ records }}" flex></d3-line-chart>

#### Styling
  - chart html is ready for styling which shouldn't affect responsiveness
  - please set chart's width & height by css or add it to layout (you can use flex attribute on it)

@element d3-line-chart
@demo http://polymoar.github.io/components/d3-line-chart/demo.html
@blurb Responsive and configurable Polymer element for line charts based on D3.js library.
@status alpha
@homepage https://github.com/Polymoar/d3-line-chart
-->
<polymer-element name="d3-line-chart">
  <template>
    <link rel="stylesheet" href="d3-line-chart.css">
    <div id="container" fit layout vertical>
      <template if="{{ name }}">
        <div id="title">{{ name }}</div>
      </template>
      <div flex layout vertical?="{{ vertical }}" horizontal?="{{ !vertical }}">
        <div id="chart" flex>
          <svg id="paper"></svg>
          <template if="{{ responsive }}">
            <px10-element-resize-detector target="{{ }}" on-resize="{{ prepare }}"></px10-element-resize-detector>
          </template>
        </div>
        <template if="{{ legend }}">
          <div id="legend" vertical?="{{ vertical }}">
            <template repeat="{{ dataset in metadata }}">
              <div class="entry">
                <core-icon icon="label"></core-icon>
                <span>{{ dataset.label }}</span>
              </div>
            </template>
          </div>
        </template>
      </div>
    </div>
  </template>
  <script>
    (function(){
      /* TODO:
       * - scale as object for config
       * - ticks control
       * - configurable svg (line & axis colors and widths etc)
       * - refactor labels display and similar (messy)
       * - refactor helper functions
       */
      Polymer({

        //published attributes
        publish: {
          /**
           * Chart title
           *
           * @attribute name
           * @type String
           * @default null
           */
          name: null,
          /**
           * Array containing axes configuration. Each axis configuration is an object as described below:
           * ```
           * [{
           *    name: String (required)
           *    label: String
           *    scale: String - scale of axis, defaults to scale attribute value
           *    interpolation: String - mode of line interpolation for axis, defaults to interpolation attribute value
           * }, ...]
           * ```
           * If not set defaults to:
           * ```
           * [{ name: 'xAxis' }, { name: 'yAxis' }]
           * ```
           * Note that x axis configuration should be first object in array and chart can display at most 3 axes (x, y1, y2)
           *
           * @attribute axes
           * @type Array
           * @default null
           */
          axes: null,
          /**
           * Array containing series configuration. Each series configuration is an object as described below:
           * ```
           * [{
           *    label: String (recommended if hideLegend not set)
           *    axis: String - name of axis the series belongs to, if not set defaults to 'yAxis' which exists only if you did not defined own axes
           *    interpolation: String - mode of line interpolation for series, if not set defaults to axis interpolation mode
           *    x: function(record) - function getting x from record, if not set gets record[0] or record index + 1
           *    y: function(record) - function getting y from record, if not set gets record[1]
           * }, ...]
           * ```
           * Note that first element of array is drawn with lowest 'z-index'
           *
           * @attribute metadata
           * @type Array
           * @default null
           */
          metadata: null,
          /**
           * Array of records in form of:
           *  - Objects (requires usage of metadata.y and recommended metadata.x)
           *  - Arrays (does not require x y getters but you can still use them for derivative series display)
           *
           * @attribute data
           * @type Array
           * @default null
           */
          data: null,
          /**
           * Default line interpolation mode
           * #### Possible values:
           *  - `linear` - piecewise linear segments, as in a polyline.
           *  - `linear-closed` - close the linear segments to form a polygon.
           *  - `step` - alternate between horizontal and vertical segments, as in a step function.
           *  - `step-before` - alternate between vertical and horizontal segments, as in a step function.
           *  - `step-after` - alternate between horizontal and vertical segments, as in a step function.
           *  - `basis` - a B-spline, with control point duplication on the ends.
           *  - `basis-open` - an open B-spline; may not intersect the start or end.
           *  - `basis-closed` - a closed B-spline, as in a loop.
           *  - `bundle` - equivalent to basis, except the tension parameter is used to straighten the spline.
           *  - `cardinal` - a Cardinal spline, with control point duplication on the ends.
           *  - `cardinal-open` - an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
           *  - `cardinal-closed` - a closed Cardinal spline, as in a loop.
           *  - `monotone` - cubic interpolation that preserves monotonicity in y.
           *
           * @attribute interpolation
           * @type String
           * @default 'linear'
           */
          interpolation: 'linear',
          /**
           * Default scale mode for axes
           * #### Possible values:
           *  - `linear` - no scale transformation
           *  - `time` - prepared for date / time / datetime values (automatically finds desired tick format)
           *  - `sqrt` - power transform with expotent 0.5
           *  - `log` - logarithmic transform with base 10 (requires x !== 0)
           *
           * @attribute scale
           * @type String
           * @default 'linear'
           */
          scale: 'linear',
          /**
           * The `responsive` attribute if set enables triggering chart size adjustment after resize.
           *
           * @attribute responsive
           * @type boolean
           * @default false
           */
          responsive: {
            value: false,
            reflect: true
          },
          /**
           * The `vertical` attribute if set enables placing legend on the bottom of chart.
           *
           * @attribute vertical
           * @type boolean
           * @default false
           */
          vertical: {
            value: false,
            reflect: true
          },
          /**
           * The `exact` attribute if set disables broadening chart y axes range which is applied for better display of data series close to range extremes.
           *
           * @attribute exact
           * @type boolean
           * @default false
           */
          exact: {
            value: false,
            reflect: true
          },
          /**
           * The `legend` attribute if set enables legend display.
           *
           * @attribute legend
           * @type boolean
           * @default false
           */
          legend: {
            value: false,
            reflect: true
          },
          /**
           * Object with settings for default svg margins override
           * #### Properties:
           *  - `top` - default 0
           *  - `right` - default 60
           *  - `bottom` - default 60
           *  - `left` - default 60
           *
           * @attribute margin
           * @type Object
           * @default null
           */
          margin: null
        },

        //watchers
        observe: {
          metadata: 'prepare',
          scale: 'prepare',
          interpolation: 'prepare',
          margin: 'prepare',
          axes: 'prepare',
          data: 'redraw',
          range: 'redraw',
          exact: 'redraw'
        },

        //lifecycle
        ready: function(){
          var me = this;
          me.uid = ("0000" + (Math.random()*Math.pow(36,4) << 0).toString(36)).slice(-4); //required because of svg clip paths overlapping
          me.margin = me.margin || { top: 10, right: 60, bottom: 60, left: 60};
          me.axes = me.axes || [
            { name: 'xAxis' },
            { name: 'yAxis' }
          ];
          me.metadata = me.metadata || [{ axis: 'yAxis' }];
        },
        domReady: function(){
          this.prepare();
        },

        /**
         * The `prepare` method recreates chart with updated configuration attributes & size.
         *
         * @method prepare
         * @return {boolean} Returns true if succeeded, otherwise false.
         */
        prepare: function(){
          var me = this,
            bounds = me.$.chart.getBoundingClientRect(),
            svg = d3.select(me.$.paper);

          //clear svg
          svg.selectAll('*').remove();

          //if no config present abandon preparation
          if(!me.axes || !me.metadata){
            return false;
          }

          //if layout not finished yet delay preparation of chart
          if(!bounds.width || !bounds.height){
            return false;
          }

          //update svg size to match component
          svg.attr('width', bounds.width);
          svg.attr('height', bounds.height);

          //calculate size of chart draw area
          var margin = me.margin,
            width = bounds.width - margin.left - margin.right,
            height = bounds.height - margin.top - margin.bottom,
            xAxis = me.axes[0];

          //define scale for x axis and y axes
          me.axes.forEach(function(axis, i){
            axis.scale = axis.scale || me.scale || 'linear';
            //TODO: config for scales
            axis._scale = ((axis.scale === 'time') ? d3.time.scale() : d3.scale[axis.scale]()).range((i > 0) ? [height, 0] : [0, width]);
          });

          //create focus objects configurations
          var lines = [], line;
          me.metadata.forEach(function(dataset){
            dataset.axis = dataset.axis || 'yAxis';
            var axis = me.axes.filter(function(axis){
                return axis.name === dataset.axis;
              })[0];

            if(axis){
              line = d3.svg.line();
              line.interpolate(dataset.interpolation || axis.interpolation || me.interpolation || 'linear');
              line.x(function(d){
                return xAxis._scale((dataset.x) ? dataset.x(d) : (isNaN(d[0])) ? me.data.indexOf(d) + 1 : d[0]);
              });
              line.y(function(d){
                return axis._scale((dataset.y) ? dataset.y(d) : d[1]);
              });
              lines.push(line);
            }
          });

          //settle axes orientation
          var axisOrientation,
            orientation = [
              'bottom',
              'left',
              'right'
            ];
          me.axes.forEach(function(axis, key){
            axisOrientation = orientation[key];
            if(axisOrientation){
              axis._axis = d3.svg.axis().scale(axis._scale).orient(axisOrientation);
            }
          });

          //create svg groups
          var focus = svg.append("g").attr("class", "focus").attr("transform", "translate(" + margin.left + "," + margin.top + ")").attr("clip-path", "url(#cp" + me.uid + ")"),
            axes = svg.append("g").attr("class", "axes").attr("transform", "translate(" + margin.left + "," + margin.top + ")"),
            labels = svg.append("g").attr("class", "labels");

          //append axes and labels to svg
          var _axis;
          me.axes.forEach(function(axis, key){
            _axis = axes.append("g");
            if(key === 0){
              _axis.attr("class", "x axis").attr("transform", "translate(0," + height + ")");
              if(axis.label){
                labels.append("text").attr("y", margin.top + height + margin.bottom).attr("x", margin.left + (width / 2)).attr("dy", "-1em").style("text-anchor", "middle").text(axis.label);
              }
            }else if(key < 3){
              _axis.attr("class", "y axis " + axis.name);
              if(key === 2){
                _axis.attr("transform", "translate(" + width + " ,0)");
                if(axis.label){
                  labels.append("text").attr("transform", "rotate(-90)").attr("y", width + margin.right + margin.left).attr("x", 0 - (height/2)).attr("dy", "-1em").style("text-anchor", "middle").text(axis.label);
                }
              }else if(axis.label){
                labels.append("text").attr("transform", "rotate(90)").attr("y", 0).attr("x", height/2).attr("dy", "-1em").style("text-anchor", "middle").text(axis.label);
              }
            }
            _axis.call(axis._axis);
          });

          //append lines to svg
          lines.forEach(function(line, i){
            focus.append("path").attr("class", "line l" + i);
          });

          //append clipping path to svg
          svg.append("defs").append("clipPath")
            .attr("id", "cp" + me.uid)
            .append("rect")
            .attr("width", width)
            //height & translate manipulation for proper exact display
            .attr("height", height + 4)
            .attr("transform", "translate(0 ,-2)");

          //create redraw function
          me.redraw = function(){
            if(me.data){

              //setting domains
              var min, max, epsilon;
              me.axes.forEach(function(axis, key){
                if(key > 0){
                  if(axis.range && axis.range.length === 2){ //if axis has predefined range
                    axis._scale.domain(axis.range);
                  }else{
                    //find y range for all data in axis
                    min = me.d3y('min', axis.name);
                    max = me.d3y('max', axis.name);
                    epsilon = (!me.exact) ? (max - min) * 0.02 : 0; //if allowed broaden range for nicer looks
                    axis._scale.domain([min - epsilon, max + epsilon]);
                  }
                }else{
                  if(me.range){ //if user defined specific range
                    axis._scale.domain(me.range);
                  }else{
                    //find x range for all data
                    axis._scale.domain([me.d3x('min'), me.d3x('max')]);
                  }
                }
              });

              //update lines
              lines.forEach(function(line, i){
                focus.select(".line.l" + i).datum(me.data).transition().attr("d", line);
              });
            }

            //update axes
            axes.select(".x.axis").transition().call(xAxis._axis);
            me.axes.forEach(function(axis){
              axes.select(".y.axis." + axis.name).transition().call(axis._axis);
            });
          };

          //do first redraw
          me.redraw();

          //return success
          return true;
        },

        /**
         * The `redraw` method redraws chart with current data
         *
         * @method redraw
         */
        redraw: function(){
          //placeholder
        },

        //helpers
        d3x: function(fun){ //do fun for all x values
          var me = this;
          return d3[fun](me.metadata.map(function(dataset){
            if(dataset.x){
              return d3[fun](me.data.map(dataset.x));
            }else{
              return d3[fun](me.data.map(function(record){
                return (isNaN(record[0])) ? me.data.indexOf(record) + 1 : record[0]; //TODO: helper for getting x, y more than one place this happens
              }));
            }
          }));
        },
        d3y: function(fun, axisName){ //do fun for all y values from selected axis
          var me = this,
            datasets = me.metadata.filter(function(dataset){
              return dataset.axis === axisName;
            });
          return d3[fun](datasets.map(function(dataset){
            if(dataset.y){
              return d3[fun](me.data.map(dataset.y));
            }else{
              return d3[fun](me.data.map(function(record){
                return record[1];
              }));
            }
          }));
        }
      });
    })();
  </script>
</polymer-element>
